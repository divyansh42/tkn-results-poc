# .github/workflows/reproduce_tkn_hang.yaml
name: Reproduce TKN Logs Hang

on:
  workflow_dispatch: # Allows manual triggering
  # push: # Uncomment to run on every push (be mindful of resource usage)
  #   branches:
  #     - main

jobs:
  reproduce-hang:
    runs-on: ubuntu-latest
    timeout-minutes: 15 # Set a reasonable timeout for the entire job

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.22' # Use a recent Go version if tkn needs it

      - name: Install kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'v1.28.0' # Or desired kubectl version

      - name: Install Kind
        run: |
          # For AMD64
          [ $(uname -m) = x86_64 ] && curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64
          # For ARM64
          [ $(uname -m) = aarch64 ] && curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-arm64
          chmod +x ./kind
          sudo mv ./kind /usr/local/bin/kind
          kind version

      - name: Create Kind cluster
        run: kind create cluster --name tekton-test

      - name: Setup Tekton Pipelines and CLI
        uses: openshift-pipelines/setup-tektoncd@v1
        with:
          pipeline_version: latest
          cli_version: latest
          setup_registry: "true"
          patch_etc_hosts: "true"

      - name: Create Tekton Resources (Task, Pipeline, PipelineRun)
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: tekton.dev/v1beta1
          kind: Task
          metadata:
            name: echo-and-sleep
          spec:
            params:
              - name: MESSAGE
                type: string
                description: The message to echo
              - name: SLEEP_SECONDS
                type: string
                description: How many seconds to sleep after echoing
                default: "10"
            steps:
              - name: echo
                image: ubuntu
                script: |
                  #!/bin/bash
                  echo "Starting step 'echo': $(params.MESSAGE)"
              - name: sleep
                image: ubuntu
                script: |
                  #!/bin/bash
                  echo "Starting step 'sleep' for $(params.SLEEP_SECONDS) seconds..."
                  sleep $(params.SLEEP_SECONDS)
                  echo "Finished sleeping."
          EOF

          cat <<EOF | kubectl apply -f -
          apiVersion: tekton.dev/v1beta1
          kind: Pipeline
          metadata:
            name: long-running-pipeline
          spec:
              tasks:
                - name: first-task
                  taskRef:
                    name: echo-and-sleep
                  params:
                    - name: MESSAGE
                      value: "This is the first task."
                    - name: SLEP_SECONDS
                      value: "5"

                - name: second-task
                  taskRef:
                    name: echo-and-sleep
                  params:
                    - name: MESSAGE
                      value: "This is the second task, a bit longer."
                    - name: SLEEP_SECONDS
                      value: "15"
                  runAfter:
                    - first-task

                - name: third-task
                  taskRef:
                    name: echo-and-sleep
                  params:
                    - name: MESSAGE
                      value: "This is the third task, a long one."
                    - name: SLEEP_SECONDS
                      value: "60"
                  runAfter:
                    - second-task
          EOF

          PIPELINERUN_NAME=$(kubectl apply -f - -o jsonpath='{.metadata.name}' <<EOF
          apiVersion: tekton.dev/v1beta1
          kind: PipelineRun
          metadata:
            generateName: long-running-pipeline-run-
          spec:
            pipelineRef:
              name: long-running-pipeline
          EOF
          )
          echo "PIPELINERUN_NAME=$PIPELINERUN_NAME" >> $GITHUB_ENV
          echo "Started PipelineRun: $PIPELINERUN_NAME"

      - name: Follow PipelineRun logs and check for hang
        run: |
          # Run tkn logs in background and capture its PID
          tkn pipelinerun logs --exit-with-pipelinerun-error -f "$PIPELINERUN_NAME" > konflux_tasks_logs.txt 2>&1 &
          TKN_PID=$!
          echo "tkn logs process started with PID: $TKN_PID"

          # Wait for a reasonable time, e.g., 2 minutes beyond expected pipeline run duration
          # The pipeline takes 5 + 15 + 60 = 80 seconds. Let's wait 120 seconds.
          WAIT_TIME=120
          echo "Waiting for $WAIT_TIME seconds for the pipelinerun to complete and tkn to exit..."
          sleep $WAIT_TIME

          # Check if the tkn process is still running
          if ps -p $TKN_PID > /dev/null
          then
             echo "Error: tkn pipelinerun logs command is still running (hung) after $WAIT_TIME seconds!"
             echo "Process details:"
             ps -fp $TKN_PID
             echo "Captured logs so far:"
             cat konflux_tasks_logs.txt
             # Attempt to get final pipelinerun status from kubectl
             echo "Final PipelineRun status from kubectl:"
             kubectl get pipelinerun "$PIPELINERUN_NAME"
             # Kill the hung process to allow the job to terminate
             kill $TKN_PID
             exit 1 # Fail the job
          else
             echo "tkn pipelinerun logs command exited successfully."
             echo "Final logs:"
             cat konflux_tasks_logs.txt
             # Verify actual PipelineRun status from kubectl
             echo "Final PipelineRun status from kubectl:"
             kubectl get pipelinerun "$PIPELINERUN_NAME"
          fi

      - name: Clean up Kind cluster
        if: always() # Run cleanup even if previous steps fail
        run: kind delete cluster --name tekton-test