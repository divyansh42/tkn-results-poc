package config

import (
	"encoding/json"
	"errors"
	"github.com/AlecAivazis/survey/v2"
	"github.com/divyansh42/tkn-results/pkg/cli"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/rest"
	"k8s.io/client-go/tools/clientcmd"
	"k8s.io/client-go/tools/clientcmd/api"
	"path"
	"strconv"
	"time"
)

type Config interface {
	Get() *cli.Config
	GetObject() runtime.Object
	Set(prompt bool) error
	//Reset() error
}

type config struct {
	ConfigAccess clientcmd.ConfigAccess
	APIConfig    *api.Config
	RESTConfig   *rest.Config
	ClientConfig *cli.Config
	Extension    *Extension
}

type Extension struct {
	runtime.TypeMeta      `json:",inline"`
	APIPath               string `json:"api-path"`
	Host                  string `json:"host"`
	Token                 string `json:"token"`
	Timeout               string `json:"timeout,omitempty"`
	InsecureSkipTLSVerify string `json:"insecure-skip-tls-verify,omitempty"`
}

// DeepCopy is an autogenerated deep copy function, copying the receiver, creating a new Extension.
func (in *Extension) DeepCopy() *Extension {
	if in == nil {
		return nil
	}
	out := new(Extension)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deep copy function, copying the receiver, creating a new runtime.Object.
func (in *Extension) DeepCopyObject() runtime.Object {
	return in.DeepCopy()
}

// DeepCopyInto is an autogenerated deep copy function, copying the receiver, writing into out. in must be non-nil.
func (in *Extension) DeepCopyInto(out *Extension) {
	*out = *in
	out.TypeMeta = in.TypeMeta
}

const (
	ServiceLabel  string = "app.kubernetes.io/name=tekton-results-api"
	ExtensionName string = "tekton-results"
	Group         string = "results.tekton.dev"
	Version       string = "v1alpha2"
	Kind          string = "Client"
	Path          string = "apis"
)

func NewConfig() (Config, error) {
	kubeconfigPath := clientcmd.RecommendedHomeFile
	// Load kubeConfig
	cc := getRawKubeConfigLoader(kubeconfigPath)
	ca := cc.ConfigAccess()
	ac, err := cc.RawConfig()
	if err != nil {
		return nil, err
	}
	rc, err := cc.ClientConfig()
	if err != nil {
		return nil, err
	}

	c := &config{
		ConfigAccess: ca,
		APIConfig:    &ac,
		RESTConfig:   rc,
	}
	if err := c.LoadExtension(); err != nil {
		return nil, err
	}

	return c, c.LoadClientConfig()
}

// getRawKubeConfigLoader is the equivalent of ToRawKubeConfigLoader()
func getRawKubeConfigLoader(kubeconfigPath string) clientcmd.ClientConfig {
	// Set explicit path for kubeconfig
	loadingRules := &clientcmd.ClientConfigLoadingRules{ExplicitPath: kubeconfigPath}
	configOverrides := &clientcmd.ConfigOverrides{}

	// Return the clientcmd.ClientConfig (equivalent to ToRawKubeConfigLoader)
	return clientcmd.NewNonInteractiveDeferredLoadingClientConfig(loadingRules, configOverrides)
}

func (c *config) LoadExtension() error {
	cc := c.APIConfig.Contexts[c.APIConfig.CurrentContext]
	if cc == nil {
		return errors.New("current context is not set in kubeconfig")
	}
	c.Extension = new(Extension)
	e := cc.Extensions[ExtensionName]
	if e == nil {
		c.SetVersion()
		return c.Persist()
	}
	return json.Unmarshal(e.(*runtime.Unknown).Raw, c.Extension)
}

func (c *config) LoadClientConfig() error {
	//rc := rest.CopyConfig(c.RESTConfig)
	//
	//gv := c.Extension.TypeMeta.GroupVersionKind().GroupVersion()
	//rc.GroupVersion = &gv
	//
	//if c.Extension.Host != "" {
	//	rc.Host = c.Extension.Host
	//}
	//
	//if c.Extension.APIPath != "" {
	//	rc.APIPath = c.Extension.APIPath
	//}
	//
	//if c.Extension.Token != "" {
	//	rc.BearerToken = c.Extension.Token
	//}
	//rc.APIPath = path.Join(rc.APIPath, Path)
	//u, p, err := rest.DefaultServerUrlFor(rc)
	//if err != nil {
	//	return err
	//}
	//u.Path = p
	//
	//c.ClientConfig = &cli.Config{
	//	Transport:  tc,
	//	URL:        u,
	//	Timeout:    c.RESTConfig.Timeout,
	//	ClientType: c.Extension.ClientType,
	//}
	rc := rest.CopyConfig(c.RESTConfig)

	gv := c.Extension.TypeMeta.GroupVersionKind().GroupVersion()
	rc.GroupVersion = &gv

	if c.Extension.Host != "" {
		rc.Host = c.Extension.Host
	}

	if c.Extension.APIPath != "" {
		rc.APIPath = c.Extension.APIPath
	}

	if c.Extension.Token != "" {
		rc.BearerToken = c.Extension.Token
	}
	if i, err := strconv.ParseBool(c.Extension.InsecureSkipTLSVerify); err == nil {
		if i {
			rc.TLSClientConfig = rest.TLSClientConfig{}
		}
		rc.Insecure = i
	}

	if d, err := time.ParseDuration(c.Extension.Timeout); err != nil {
		rc.Timeout = d
	}

	//if c.Extension.Impersonate != "" {
	//	rc.Impersonate = rest.ImpersonationConfig{
	//		UserName: c.Extension.Impersonate,
	//		UID:      c.Extension.ImpersonateUID,
	//		Groups:   strings.Split(c.Extension.ImpersonateGroups, ","),
	//	}
	//}

	tc, err := rc.TransportConfig()
	if err != nil {
		return err
	}

	rc.APIPath = path.Join(rc.APIPath, Path)
	u, p, err := rest.DefaultServerUrlFor(rc)
	if err != nil {
		return err
	}
	u.Path = p

	c.ClientConfig = &cli.Config{
		Transport: tc,
		URL:       u,
		Timeout:   c.RESTConfig.Timeout,
	}

	return nil
}

func (c *config) SetVersion() {
	c.Extension.TypeMeta.SetGroupVersionKind(schema.GroupVersionKind{
		Group:   Group,
		Version: Version,
		Kind:    Kind,
	})
}

func (c *config) GetObject() runtime.Object {
	return c.Extension
}

func (c *config) Get() *cli.Config {
	return c.ClientConfig
}

func (c *config) Persist() error {
	c.APIConfig.Contexts[c.APIConfig.CurrentContext].Extensions[ExtensionName] = c.Extension
	return clientcmd.ModifyConfig(c.ConfigAccess, *c.APIConfig, false)
}

func (c *config) Set(prompt bool) error {
	// get data from prompt in enabled
	if prompt {
		if err := c.Prompt("Host", &c.Extension.Host, c.Host()); err != nil {
			return err
		}
		if err := c.Prompt("Token", &c.Extension.Token, c.Token()); err != nil {
			return err
		}
		if err := c.Prompt("API Path", &c.Extension.APIPath, ""); err != nil {
			return err
		}
		if err := c.Prompt("Insecure Skip TLS Verify", &c.Extension.InsecureSkipTLSVerify, []string{"true", "false"}); err != nil {
			return err
		}
	}

	return c.Persist()
}

func (c *config) Prompt(name string, value *string, data any) error {
	var p survey.Prompt

	m := name + " : "

	switch d := data.(type) {
	case string:
		p = &survey.Input{
			Message: m,
			Default: d,
		}
	case []string:
		p = &survey.Select{
			Message: m,
			Options: d,
		}
	default:
		p = &survey.Input{
			Message: m,
		}
	}

	return survey.AskOne(p, value)
}

func (c *config) Host() any {
	routes, err := getRoutes(c.RESTConfig)
	if err != nil {
		return err
	}

	var hosts []string
	for _, route := range routes {
		host := "http://" + route.Spec.Host
		if route.Spec.TLS != nil {
			host = "https://" + route.Spec.Host
		}
		hosts = append(hosts, host)
	}
	return hosts
}

func (c *config) Token() any {
	return c.RESTConfig.BearerToken
}
